# store_reports
Converting raw CSV files to useful data

# требования к продукту
На торговом предприятии отчеты приходят в csv файлах. Необходимо автоматизировать анализ двух типов отчетов: отчёты о доставке груза CRG (много единиц товара) и об операциях над единицами товара SKU. Отчёты имеют такие колонки:

CRG
Дата, Время, Номер накладной, Вес, Откуда (другой склад или населенный пункт), Склад (куда прибыл), Стоимость доставки, Стоимость закупки

SKU
Дата, Время, SKU, Склад, Тип операции (прибытие, перемещение, продажа, утилизация), Номер накладной, ИД места на складе, Срок годности, Стоимость операции (отрицательная если расходы, положительная если прибыль), Комментарий

Примеры отчётов будут предоставлены через несколько дней.

При анализе этих отчётов необходимо создать новые файла формата TXT в которых:
- Будут сохранены все колонки исходного отчёта
- По горизонтали в каждом ряду каждая колонка будет начинаться в одном месте
- Ширина каждой колонки будет подогнана под тип данных и не должна обрезать
- Свободное место заполнять пробелами
- В качестве разделителя колонок использовать символ |

Так же на основании этих двух отчётов необходимо создать дополнительные отчёты, точные требования по которым еще уточняются:
- Отчёт о реализации каждого CRG
- Отчёт о каждой продаже SKU
- Отчёт о каждой утилизации SKU
- Отчёт о текущем состоянии складов
- Отчёт о приближающемся истечении срока годности

# Отчёт о приближающемся истечении срока годности

## Входные данные:

- `start_date` - дата от которой отсчитывать в формате DD.MM.YYYY (по умолчанию - сегодняшняя)
- `warning_period` - период "приближения" (по умолчанию две недели)

## Выходные данные:

- Expiration date (отображаются только те записи, в которых эта дата в промежутке между `start_date` и `start_date` + `warning_period`)
- SKU
- Warehouse (текущий)
- Warehouse cell ID (текущий)
- Last operation date
- First arrival date

### работа кода class ExpirationReport

1. Создаём объект  SKUReport, а потом уже через этот объект вызываем родительский метод read_report
2. Программа обращается к методу read_report родительского класса REPORT.
   - Читает файл который указан в свойствах класса file_name.
   - Заполняет остальные свойства класса REPORT такие как qty_of_column, где находит количество колонок, 
     после чего name_of_column заполняет название этих колонок, и далее width_of_column находит самое длинное значение в каждой колонке и записывает его.

2. Обращаемся к методу read_report класса наследника SKU_REPORT.
   - Читает файл SKU report типа CSV
   - На каждый ряд в отчете создает объект класса SKU и хранит его.
   - Вызывает родительский метод read_report.
   - Задает поле width_of_column.

3.  Создаем объект ExpirationReport 
3.1. Вызывает init() родительского класса, передавая ему значения аргументов - '', количество колонок qty_column - 6 и name_of_column название самих колонок - ['Expiration date', 'SKU', 'Warehouse', 'Warehouse cell ID', 'Last operation date', 'First arrival date']. 
3.2. Создаются атрибуты класса ExpirationReport:
   -  sku_rows, в который передается список объектов класса SKU.
   - start_date, которому даем значение конкретной даты формата date.
   -  warning_period_days которое равно целому числу 14, для дпльнейшего вычисления срока годности
   - end_date вычисляет дату окончания срока годности

4. Метод read_report вызывает метод _analyze_data() соего же класса ExpirationReport для анализа данных о SKU.

5. Метод  _analyze_data():
   - создаем словарь sku_dict, где ключом является SKU, а значением - список операций по этому SKU
   - если срок годности находится между текущей датой и датой предупреждения, добавляем строку в список операций по SKU в словаре sku_dict
   - для каждого SKU из sku_dict получаем последнюю операцию и первую операцию по нему
   - если последняя операция - move или first_arrival, то создаем словарь report_row с информацией о 'Expiration date', 'SKU', 'Warehouse', 'Warehouse cell ID', 'Last operation date', 'First arrival date' 
   - добавляем report_row в список строк отчета self.rows класса REPORT.

6. Далее обращаемся к методу convert_to_txt из родительского класса Report который записывает отчет в файл формата txt.

В дальнейшем на автоматизацию так же могут направить и другие отчеты, поэтому программное решение должно быть открытым к изменениям.


# Отчёт о продажах SKU:

## Выходные данные:

- SKU
- Warehouse
- Warehouse cell ID
- Sale date
- First arrival date
- Sell cost
- Cost of transportation (all operation sum except first arrival)

### работа кода class SaleReport

1. Создаём объект  SKUReport, а потом уже через этот объект вызываем родительский метод read_report
2. Программа обращается к методу read_report родительского класса REPORT.
   - Читает файл который указан в объекте класса file_name.
   - Заполняет остальные объекты класса REPORT такие как qty_of_column, где находит количество колонок, после чего name_of_column заполняет название этих колонок, и далее width_of_column находит самое длинное значение в каждой колонке и записывает его.

2.  Обращаемся к методу read_report класса наследника SKU_REPORT.
2.1. Читает файл SKU report типа CSV
2.2. На каждый ряд в отчете создает объект класса SKU и хранит его.
   - Вызывает родительский метод read_report.
   - Задает поле width_of_column.

3.  Создаем объект SaleReport
   - Вызывает init() родительского класса, передавая ему значения аргументов - '', количество колонок qty_column - 7 и name_of_column название самих колонок - ['SKU', 'Warehouse', 'Warehouse cell ID', 'Sale date', 'First arrival date', 'Operation_cost', 'Cost of transportation']. 
   - Создаётся атрибут класса SaleReport -  sku_rows, в который передается список объектов класса SKU.
  
4.  Метод read_report вызывает метод _analyze_sale() своего же класса SaleReport для анализа продаж SKU.

5. Метод analyze_sale():
   - создаем пустой словарь, в котором будем хранить все операции для каждого SKU
   - если SKU не встречалось раньше, создаем новий список операций
   - добавляем в найденую операцию для соответствующего SKU в список
   - для каждого SKU из словаря sku_dict и соответствующего ему списка операций получаем последнюю операция, которая была sale
   - создаем список всех трат на транспортировку товара кроме первой и последней операции
   - добавляем информацию о продаже и затратах на транспортировку в отчет


6.  Обращаемся к методу convert_to_txt из родительского класса Report который записывает отчет в файл формата txt.

Отчёт о состоянии складов:

- Warehouse ID
- Количество SKU на складе сейчас
- Количество товаров проданных с этого склада
- Количество утилизированных товаров на этом складе
- Максимальное количество занятых полок (исторически пиковая нагрузка)
- Самое первое прибытие товара на склад

